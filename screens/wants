// ----------------------------------------------------------------
// New Typing Indicator Component (STAGGERED Fill, Bounce, Disappear, and Repeat)
// ----------------------------------------------------------------
const TypingIndicator = () => {
    // Animated values for TranslateY (bounce) and Opacity (fill/disappear)
    const bounceValues = [useRef(new Animated.Value(0)).current, useRef(new Animated.Value(0)).current, useRef(new Animated.Value(0)).current];
    const opacityValues = [useRef(new Animated.Value(0)).current, useRef(new Animated.Value(0)).current, useRef(new Animated.Value(0)).current];
    
    const bounceHeight = -20; // Increased bounce height as requested
    const duration = 300; // Total bounce duration (up/down)
    const staggerDelay = 150; // Delay between dot animations
    const bounceCycles = 2; // Total up/down pairs
    const pauseTime = 500; // Pause between full cycles

    const createDotAnimation = (index) => {
        // Animation blocks
        const bounceUp = Animated.timing(bounceValues[index], { toValue: bounceHeight, duration: duration / 2, useNativeDriver: true });
        const bounceDown = Animated.timing(bounceValues[index], { toValue: 0, duration: duration / 2, useNativeDriver: true });
        const fadeIn = Animated.timing(opacityValues[index], { toValue: 1, duration: 150, useNativeDriver: true });
        const fadeOut = Animated.timing(opacityValues[index], { toValue: 0, duration: 150, useNativeDriver: true });
        
        // Staggered sequence for one dot
        return Animated.sequence([
            // 1. Staggered Fill (Wait)
            Animated.delay(index * staggerDelay), 
            fadeIn,
            
            // 2. Staggered Bounce Loop
            Animated.loop(
                Animated.sequence([bounceUp, bounceDown]),
                { iterations: bounceCycles }
            ),
            
            // 3. Staggered Disappear (Wait for others to finish their bounce/fade)
            // Use delay to ensure all dots are visible for the bounce duration
            Animated.delay((2 - index) * staggerDelay + bounceCycles * duration), 
            fadeOut,
            
            // 4. Wait for the total cycle time before the parallel loop repeats
            Animated.delay(pauseTime), 
        ]);
    };
    
    useEffect(() => {
        // Reset initial states
        bounceValues.forEach(val => val.setValue(0));
        opacityValues.forEach(val => val.setValue(0));
        
        // Loop the entire staggered sequence indefinitely in parallel
        const animations = bounceValues.map((_, index) => createDotAnimation(index));
        
        const indicatorAnimation = Animated.loop(
            Animated.parallel(animations)
        );

        indicatorAnimation.start();
        return () => indicatorAnimation.stop();
    }, []);

    // Render the 3 bouncing dots
    return (
        <View style={styles.typingIndicatorContainer}>
            {bounceValues.map((bounce, index) => (
                <Animated.View 
                    key={index} 
                    style={[
                        styles.typingDotWrapper, 
                        { 
                            transform: [{ translateY: bounce }], 
                            opacity: opacityValues[index]
                        }
                    ]}
                >
                    <FontAwesome5 
                        name="circle" 
                        size={6} 
                        color="#7C3AED" // Changed color to primary purple for visibility against the chat background
                        solid
                        style={styles.typingDot}
                    />
                </Animated.View>
            ))}
        </View>
    );
};